1 介绍多线程编程，并发，并行，事件驱动机制
2 多线程编程面临的挑战
3 GO RACE机制
4 在示例代码中,使用了两种方式来实现多线程爬虫，第一种方式是ConcurrentMutex方法：在读取MAP的时候加锁，防止两个线程同时读取到一个未爬取状态的URL,并对其进行
重复爬取；第二种方式是
func ConcurrentMutex(url string, fetcher Fetcher, f *fetchState) {
	// 实验证明，如果去掉f.mu.Lock()和f.mu.Unlock()，会概率性的报错：fatal error: concurrent map read and map write。
	这样的报错在jAVA中操作一些非线程安全的类的时候比如ARRAYLIST,也会抱类似的错误。
	f.mu.Lock()
	already := f.fetched[url]
	f.fetched[url] = true
	f.mu.Unlock()

	if already {
		return
	}

	urls, err := fetcher.Fetch(url)
	if err != nil {
		return
	}
	// 关于为什么这里要使用var done sync.WaitGroup这个机制，如果不使用的话，那么这里爬取任务可能在并发进行的时候，主线程已经开始
	继续处理其他的任务去了，这里根据实际情况需要来进行使用该机制或者不使用。在jAVA中类似的机制是：ExecutorService的awaitTermination方法
	var done sync.WaitGroup
	for _, u := range urls {
		done.Add(1)
		go func(u string) {
		// defer done.Done() 这样的用法是说在SURROUNDING FUNCTION执行完毕之前，一定会先执行这个方法，
		// 无论周围的方法是用什么样的方式结束的。这样是防止在执行ConcurrentMutex方法时因为意外退出，比如NULLPOINTER EXCEPTION
		// 或者是其他的异常导致退出，而不是通过正常的RETURN进行返回的时候，done.Done() 将永远不会被执行，这样的话done.Wait()将
		// 一直等待，阻塞在这里。
			defer done.Done()
			ConcurrentMutex(u, fetcher, f)
		}(u)
	}
	done.Wait()
	return
}